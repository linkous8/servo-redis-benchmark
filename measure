#!/usr/bin/env python3
import os
from collections import deque
from statistics import median, mean

import pandas as pd
import yaml
from redis import Redis as RedisClient
from measure import Measure

DESC = "Redis measure driver for Opsani Optune"
VERSION = "0.0.1"
HAS_CANCEL = True


# def calc_decayed_rank(rnk, time):
#     most_recent_datetime = max(time)
#     diff = most_recent_datetime - time
#     diff = diff.dt.total_seconds().astype(int)
#     diff_max = max(diff)
#     time_decay = 1 - diff / diff_max
#     return rnk ** time_decay


def init_redis_client():
    prefix = 'optune_redis_'
    kwargs = {k.lower()[len(prefix):]: v
              for k, v in os.environ.items()
              if k.lower().startswith(prefix)}
    return RedisClient(**kwargs)


records = pd.read_csv('~/hn_posts_updated.csv')
records['created_at'] = records['created_at'].astype('datetime64[ns]')
# rank = records['rank'] = records['num_comments'] + records['num_points']
# records['rank_decayed'] = calc_decayed_rank(records['rank'], records['created_at'])
# records.to_csv('~/hn_posts_updated.csv')


r_total = len(records)
r_popular_rank_cutoff = 100
r_popular = records[records['rank_decayed'] > r_popular_rank_cutoff]
r_popular_count = len(r_popular)
# r_popular_pct = r_popular_count / records_total
r_unpopular = records[records['rank_decayed'] <= r_popular_rank_cutoff]
r_unpopular_len = len(r_unpopular)
# r_unpopular_pct = r_unpopular_len / records_total

popular_posts_frac = .75
average_post_size_in_bytes = 75 * 1024
post_contents = open('/home/ubuntu/optune/oco/rnd.txt', 'r').read()[:average_post_size_in_bytes]

u_posts_read = 100
u_popular_count = int(u_posts_read * popular_posts_frac)
u_unpopular_count = u_posts_read - u_popular_count

client = init_redis_client()


def execute_access_pattern():
    r_pop = r_popular.sample(n=u_popular_count, replace=True)
    r_unpop = r_unpopular.sample(n=u_unpopular_count, replace=True)
    ds = r_pop.append(r_unpop)
    hits = 0

    for _, r in ds.iterrows():
        if client.get(name=r.id) is None:
            client.set(name=r.id, value=post_contents)
            continue
        hits += 1

    return hits / u_posts_read


class RedisDriver(Measure):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client = init_redis_client()

    def measure(self):
        # user_data = self.input_data.setdefault('control', {}).setdefault('userdata', {})

        self.progress = 0
        self.progress_message = "Benchmark started"
        self.print_progress()

        # Fill up the cache
        def get_mem_left_pct():
            used = int(self.client.info('memory')['used_memory']) / 1024 / 1024
            maxmem = int(self.client.config_get('maxmemory')['maxmemory']) / 1024 / 1024
            return round((1 - used / maxmem) * 100, 3)

        # Fill up cache before sampling measurements
        self.progress_message = 'Filling up cache'
        for i in range(1000):
            execute_access_pattern()
            self.progress = int((i / 1000) * 50)
            # Evictions become to appear - cache is filled up
            if get_mem_left_pct() < .1:
                self.progress = 50
                break

        # Sample measurements (hits to total requests ratio)
        samples = []
        for i in range(7):
            samples.append(execute_access_pattern())
            self.progress = 50 + int(i / 7 * 50)

        metrics = {
            'hits': {
                'values': [{'data': [(i, frac) for i, frac in enumerate(samples)]}],
                'unit': "fraction",
                'annotation': "Hits to total requests ratio.",
            },
        }

        self.progress = 100
        self.progress_message = "Benchmark completed"
        self.print_progress()

        return metrics, {}

    def describe(self):
        return {
            'hits': {
                'unit': 'fraction',
            },
        }

    def handle_cancel(self, *_, **__):
        print("\nCancelling measurement")
        self.client.flushdb()
        quit()


if __name__ == '__main__':
    driver = RedisDriver(cli_desc=DESC, supports_cancel=HAS_CANCEL, version=VERSION, progress_interval=1)
    driver.run()
