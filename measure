#!/usr/bin/env python3
import os
import random
import string

import pandas as pd
from redis import Redis as RedisClient
from measure import Measure

DESC = "Redis measure driver for Opsani Optune"
VERSION = "0.0.1"
HAS_CANCEL = True


def init_redis_client():
    prefix = 'optune_redis_'
    kwargs = {k.lower()[len(prefix):]: v
              for k, v in os.environ.items()
              if k.lower().startswith(prefix)}
    return RedisClient(**kwargs)


records = pd.read_csv('/tmp/posts.csv')
records['created_at'] = records['created_at'].astype('datetime64[ns]')


r_total = len(records)
r_popular_rank_cutoff = 100
r_popular = records[records['rank'] > r_popular_rank_cutoff]
r_popular_count = len(r_popular)
r_unpopular = records[records['rank'] <= r_popular_rank_cutoff]
r_unpopular_len = len(r_unpopular)

popular_posts_frac = .75
average_post_size_in_bytes = 75 * 1024
post_random_contents_fpath = '/tmp/post-random-contents.txt'


def write_random_contents_file(path):
    with open(path, 'w') as f:
        f.write(''.join(random.choice(string.ascii_uppercase + string.digits)
                        for _ in range(average_post_size_in_bytes)))


if not os.path.isfile(post_random_contents_fpath):
    write_random_contents_file(post_random_contents_fpath)
else:
    if os.path.getsize(post_random_contents_fpath) < average_post_size_in_bytes:
        os.remove(post_random_contents_fpath)
        write_random_contents_file(post_random_contents_fpath)

post_contents = open(post_random_contents_fpath, 'r').read()[:average_post_size_in_bytes]

u_posts_read = 100
u_popular_count = int(u_posts_read * popular_posts_frac)
u_unpopular_count = u_posts_read - u_popular_count

client = init_redis_client()


def execute_access_pattern():
    r_pop = r_popular.sample(n=u_popular_count, replace=True)
    r_unpop = r_unpopular.sample(n=u_unpopular_count, replace=True)
    ds = r_pop.append(r_unpop)
    hits = 0

    for _, r in ds.iterrows():
        if client.get(name=r.id) is None:
            client.set(name=r.id, value=post_contents)
            continue
        hits += 1

    return hits / u_posts_read * 100


class RedisDriver(Measure):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.client = init_redis_client()

    def measure(self):
        # user_data = self.input_data.setdefault('control', {}).setdefault('userdata', {})

        self.progress = 0
        self.progress_message = "Benchmark started"
        self.print_progress()

        # Fill up the cache
        def get_mem_left_pct():
            used = int(self.client.info('memory')['used_memory']) / 1024 / 1024
            maxmem = int(self.client.config_get('maxmemory')['maxmemory']) / 1024 / 1024
            return round((1 - used / maxmem) * 100, 3)

        # Fill up cache before sampling measurements
        self.progress_message = 'Filling up cache'
        for i in range(1000):
            execute_access_pattern()
            self.progress = int((i / 1000) * 50)
            # Evictions become to appear - cache is filled up
            if get_mem_left_pct() < .1:
                self.progress = 50
                break

        # Sample measurements (hits to total requests ratio)
        samples = []
        samples_take = 20
        for i in range(samples_take):
            samples.append(execute_access_pattern())
            self.progress = 50 + int(i / samples_take * 50)

        metrics = {
            'hits': {
                'values': [{'data': [(i, frac) for i, frac in enumerate(samples)]}],
                'annotation': "Percentage of hits",
            },
            'perf': {
                'value': None,
                'unit': '% hits',
            },
        }

        self.progress = 100
        self.progress_message = "Benchmark completed"
        self.print_progress()

        return metrics, {}

    def describe(self):
        return {
            'hits': {
                'unit': "percentage",
            },
            'perf': {
                'unit': '% hits',
            }
        }

    def handle_cancel(self, *_, **__):
        print("\nCancelling measurement")
        quit(0)


if __name__ == '__main__':
    driver = RedisDriver(cli_desc=DESC, supports_cancel=HAS_CANCEL, version=VERSION, progress_interval=1)
    driver.run()
